\documentclass[t,aspectratio=169, xcolor={table}]{beamer}
\usepackage{listings}
\title{Beyond 128-bit SIMD in WebAssembly}
\author{Petr Penzin}
\institute{Intel Corporation}
\date{November 6, 2019}
\begin{document}
\begin{frame}
  \titlepage
\end{frame}
\begin{frame}
\frametitle{Agenda}
Discuss next steps in evolution of Wasm SIMD instruction set.
\end{frame}
\begin{frame}
\frametitle{Proposal summary}
  \begin{itemize}
  \item Add vectors operations analogous, at lane level, to existing Wasm SIMD operations, but agnostic of the vector length
  \item Vector length defined by architecture and set by the runtime
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Design Constraints}
  \begin{itemize}
  \item Same Wasm binary to run all platforms
  \item Unambiguous instruction selection
  \item Backwards compatibility with existing Wasm SIMD instruction set % FIXME dilution of orginal "no regressions" goal?
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Alternatives}
  Longer fixed-width SIMD WebAssembly ISA
  \begin{itemize}
  \item Not universally supported in hardware
  \item Goes against WebAssembly's design goal of representing the common set of operations between hardware platforms
  \item Cross platform code generation is challenging
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Proposal}
  We propose length-agnostic variants of operations already present in Wasm \textit{simd128} proposal
  \begin{itemize}
  \item Loads and stores work with consecutive memory locations, like \textit{simd128} loads and stores
  \item Maximum vector length is set to match the hardware by runtime at startup
  \item New instructions to control the width of the vector
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Types and instructions}
New types and instructions
  \begin{itemize}
  \item $vec.<type>$ -- separate vector types for different lane types, size defaults to maximum supported by hardware
    \begin{itemize}
    \item $i8$, $i16$, $i32$, $i64$ -- integer
    \item $f32$, $f64$ -- floating point
    \end{itemize}
  \item $vec.<type>.length$ -- get number of elements in corresponding vector type
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Types and instructions}
Instructions extending existing operations in WebAssembly SIMD proposal
  \begin{itemize}
  \item $vec.<type>.<op>$ -- same lane-wise operation as in \textit{simd128} $<op>$, applied to vector of $vec.<type>.length$
  \item[] For example, $vec.f32.mul$ is identical to $f32x4.mul$ on a 4-lane vector, $vec.i32.add$ to $i32x4.add$ , and so on
  \end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
\frametitle{Example}
Vector addition, $c = a + b$, $sz$ is the size
\begin{lstlisting}
(block $loop
  (block $loop_top
    (br_if $loop (i32.lt (get_local $sz) (vec.f32.length)))
    vec.f32.load (get_local $a)
    vec.f32.load (get_local $b)
    vec.f32.add
    vec.f32.store (get_local $c)
    ;; Decrement $sz and increment $a, $b, $c
    (br $loop_top)
  )
)
(block $scalar_loop ;; Finish the remaining elements
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Code generation}
  \begin{itemize}
  \item Identical to \textit{simd128} for platforms that support only 128 bit SIMD
  \item Straight-forward extension to longer vectors on supporting platforms
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Comparison against current SIMD proposal}
  \begin{itemize}
  \item At 128-bit vector width operations are identical to current Wasm SIMD operations with sole exception of lane shuffle
  \item Transparent to developer and toolchain
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{Extension: arbitrary length}
  Support for size manipulation not multiple of maximum length, to educe WebAssembly and native instruction count.
\end{frame}
\begin{frame}
\frametitle{Additional instructions}
  \begin{itemize}
  \item $vec.<type>.set\_length$ -- set number of elements in corresponding vector type
  \item[] Takes an unsigned argument, allowed use smaller number per runtime's view of the hardware
  \end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
\frametitle{Example}
Vector addition, $c = a + b$, $sz$ is the size
\begin{lstlisting}
local $len i32
(block $loop
  (block $loop_top
    (br_if $loop (i32.eq (get_local $sz) (i32.const 0)))
    (set_local $len (vec.f32.set_length (get_local $sz)))
    vec.f32.load (get_local $a)
    vec.f32.load (get_local $b)
    vec.f32.add
    vec.f32.store (get_local $c)
    ;; Decrement $sz by $len; increment $a, $b, and $c by $len
    (br $loop_top)
  )
)
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Code generation}
  Relatively straightforward for vector instruction sets and SIMD predication
  \begin{itemize}
  \item Simple mask generation, code generation changes only needed for loads and stores
  \item Straight-forward code generation for vector instruction sets
  \end{itemize}
\end{frame}
\begin{frame}
\frametitle{~}
\huge{Thank you}
\end{frame}
\end{document}

